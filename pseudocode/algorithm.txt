# Start_node, end_node(end_node is when the patient is discharged)

#generate costs from start, end nodes to drug nodes.
for diagnosis in unique_diagnosis:
    diagnosis_df=main_df[main_df.diagnosis==diagnosis]
    # find unique patients in the diagnosis


class Graph:
    def__init__self(diagnosis_df):
        self.df=diagnosis_df
        self.unique_patients=diagnosis_df.hadm_id.unique()
        self.diagnosis_name=self.df.diagnosis[0]

    # this is repeated for each diagnosis, results are stored in json files, if 70 diagnosis, then 140 json files.
    # nodes are heterogenous, for that reasons custom cost logic is separated into two functions.
    def start_end_to_drug_cost(self)
        """
        Rationale, see how often a given drug is given on the first day of admittance, and on the last day of
        discharge, this become the respective cost between start_node_to_drug and drug_to_end_node.
        """
        drug_weight_start=defaultdict()
        drug_weight_end=defaultdict()
        for patient in unique_patients:
            patient_df=diagnosis_df[diagnosis_df.hadm_id==patient]
            admittime=patient_df.admittime[0]
            dischtime=patient_df.dischtime[0]
            for i, row in patient_df.iterrows():
                # even if does not exist, create and add one
                #TODO adjust the cost before updating
                if row.drug.startdate.day==admittime.day:
                    drug_weight_start[('start_node',row.drug]+=1
                if row.drug.enddate.day==dischtime.day:
                    drug_weight_end['end_node',row.drug]+=1

        with open(f"jsons/{self.diagnosis_name}_drug_weight_start.json","w") as file:
            json.dump(file,drug_weight_start)

        with open(f"jsons/{self.diagnosis_name}_drug_weight_end.json","w") as file:
            json.dump(file,drug_weight_end)

    def between_node_cost():
        with open(f"jsons/{self.diagnosis_name}_drugs.json","w") as file:
            json.dump(file,total_overlap)

    def heuristic(self):
        model_weights=svc(model_preprocess()) # svc should be renamed to model_weights, allowing for different models.
                with open(f"jsons/{self.diagnosis_name}_drug_weight_end.json","w") as file:
            json.dump(file,drug_weight_end)

    def return_heuristic(node_i,node_j):
       start_to_drugs, between_drugs, drugs_to_end = self.load_files()
        # is in either dict, cannot be in all.
        if (node_i,node_j) or (node_j,node_i) in start_to_drugs.keys():
            return start_to_drugs.keys['(node_i,node_j)'] or start_to_drugs.keys['(node_i,node_j)']

        if (node_i,node_j) or (node_j,node_i) in between_drugs.keys():
            return between_drugs.keys['(node_i,node_j)'] or between_drugs.keys['(node_i,node_j)']

        if (node_i,node_j) or (node_j,node_i) in drugs_to_end.keys():
            return drugs_to_end.keys['(node_i,node_j)'] or drugs_to_end.keys['(node_i,node_j)']

    def load_files(self):

        with open(f"jsons/{self.diagnosis_name}_drug_weight_start.json","r") as file:
            start_to_drugs=json.load(file)

        with open(f"jsons/{self.diagnosis_name}_drugs.json","w") as file:
            between_drugs=json.dump(file)

        with open(f"jsons/{self.diagnosis_name}_drug_weight_end.json","w") as file:
            drugs_to_end=json.dump(file)

        return start_to_drugs, between_drugs, drugs_to_end

    def construct_graph(self):
        """
        Convert dicts of nodes and edges to nx.add_edges_from() format, then construct the graph.
        """
        start_to_drugs, between_drugs, drugs_to_end = self.load_files()

        start_to_drug_edges,between_drugs_edges,drugs_to_end_edges=[],[],[]
        for tuple_ in start_to_drugs:
            start_to_drug_edges.append((*tuple_, {'cost': start_to_drugs[tuple_]})
        for tuple_ in start_to_drugs:
            between_drugs_edges.append((*tuple_, {'cost': between_drugs[tuple_]})
        for tuple_ in start_to_drugs:
            drugs_to_end_edges.append((*tuple_, {'cost': drugs_to_end[tuple_]})

        # add the list elements together and construct the final graph.
        start_to_drug_edges.extend(between_drugs_edges)
        start_to_drug_edges.extend(drugs_to_end_edges)
        self.graph.add_edges_from(start_to_drug_edges)

    def nx_a_star(self):
        print(nx.astar_path(self.graph, 'start_node', 'end_node', heuristic=return_heuristic, weight='cost')

graph_construction(list_of_paths).
1. If paths are not stored as sequences, store as sequences. ('A','B'), ('B','C')
2. Obtain unique nodes from the sequence, this can be done before step 1 if (A,B,C) are available as separate nodes.
3. Construct an adjanency matrix from nodes, each intersection shows how often a given pair appears along paths,
   basically this is the weight. (start nodes also are part of the matrix)
   For start nodes, also store them as a dict of tuple. {('A','B):2,('A','C'):1,('B','F':1)}
4. return adjacency_matrix, start_nodes_dict,average_path_length


graph_search(adjacency_matrix,start_nodes_dict,average_path_length)
1. Select the most appearing sequence from start nodes dict. ('A','B') is the first route.
2. Select the ending node from step1, which is 'B', add it to que (path_list=[])
3. search_logic():
   # termination condition
   If path_list>=average_path_length, return path_list
   Get the last element from path_list, store is as node.
   Check the adjacency matrix the row corresponding to node, find the node with the most weight.
   If there is only 1 node, select that node as the next node. (add to a list. que)
   # Here we may need to check for a self loop.
   # one step look ahead stage.
   Else, select all nodes with equal weights, lets say C and F
   temp={}
   For each selected node:
        find the node with the most cost (np.argmax).
        store in temp, as (C,E):2
   from temp, eg {(C,E):2,(F,G):1} select the key with the highest weight, if equal, select the first.
   add C,E to path_list
4. call_search logic()


A star heuristics
1. No need to iterate over all existing diagnosis from main. Select the most appearing diagnosis, or a diagnosis
   which appears n(e.g.100) number of times. Merge with prescription (I think needed for only the admit, discharge times).
   def sequential_paths(self)
   # this paths also represent graph edges, we later use custom combination then searching logic for them
Part1
2. For this dataset. First store each patients path. This would simply mean connecting each drug to its next drug.
   there is no cost here. If ('A','B') edge exists ('B','A') if exists is also stored.
   # Question, if graph is undirected, are both ('A','B') and ('B','A') listed.
   [('Syringe','Phenylephrine HCl'),('Phenylephrine HCl','Nitroglycerin'),('Nitroglycerin','LR'),('LR','Syringe')]
   For each path store the starting tuples in a separate list as starting tuples.
   Chain these paths into a single list(individual paths are also accepted) and along with starting tuples pass to
   store_graph().
Part2
3. def make_training_data()
   identify the good/bad outcomes for this dataset, where columns are all drugs, rows are unique admissions
   (or patients), does not matter much.
   def get_model_weight()
   train a model on the training data, obtain weights( weight of each drug), store as json.
4. Here you have constructed a graph logic where each drug is connected to its next two drug (has two subnodes).
   Unlike part1, we also define costs between nodes. Store costs in an adjacency matrix.
   The heuristics logic is defined. use nx_a_star() to search for the best path for a single patient.
   using the graph and heuristics for a single patient. Store each path if you want to furhterh optimize.
   Although this A star search and my custom search are on the same level, I believe path merging can also be used
   to further search for the best path using existing A star paths. It can also be used on the graph from step 4
   without heuristics, but it will not be needed.
5. If you have time, you may also connect all patients drugs to each other for a single diagnosis, but I do not know
   how heuristics may look for such graph. (DFS, BFS could be used but I think is not worth it)

Final contribution should look like this.
1. Graph logic based on date intersection between drugs, consistent heuristics logic based on ml model outcomes.
   Single patient level. If done for multiple patients, they can be combined using path merge.
2. Path merging algorithm, which operates on sequences for optimizing drug sequences.

Things to optimize:
1. Cost function, and consisten heurstic functions can be changed.
2. Path mergin algorithm can also be optimized.



