# Start_node, end_node(end_node is when the patient is discharged)

#generate costs from start, end nodes to drug nodes.
for diagnosis in unique_diagnosis:
    diagnosis_df=main_df[main_df.diagnosis==diagnosis]
    # find unique patients in the diagnosis


class Graph:
    def__init__self(diagnosis_df):
        self.df=diagnosis_df
        self.unique_patients=diagnosis_df.hadm_id.unique()
        self.diagnosis_name=self.df.diagnosis[0]

    # this is repeated for each diagnosis, results are stored in json files, if 70 diagnosis, then 140 json files.
    # nodes are heterogenous, for that reasons custom cost logic is separated into two functions.
    def start_end_to_drug_cost(self)
        """
        Rationale, see how often a given drug is given on the first day of admittance, and on the last day of
        discharge, this become the respective cost between start_node_to_drug and drug_to_end_node.
        """
        drug_weight_start=defaultdict()
        drug_weight_end=defaultdict()
        for patient in unique_patients:
            patient_df=diagnosis_df[diagnosis_df.hadm_id==patient]
            admittime=patient_df.admittime[0]
            dischtime=patient_df.dischtime[0]
            for i, row in patient_df.iterrows():
                # even if does not exist, create and add one
                #TODO adjust the cost before updating
                if row.drug.startdate.day==admittime.day:
                    drug_weight_start[('start_node',row.drug]+=1
                if row.drug.enddate.day==dischtime.day:
                    drug_weight_end['end_node',row.drug]+=1

        with open(f"jsons/{self.diagnosis_name}_drug_weight_start.json","w") as file:
            json.dump(file,drug_weight_start)

        with open(f"jsons/{self.diagnosis_name}_drug_weight_end.json","w") as file:
            json.dump(file,drug_weight_end)

    def between_node_cost():
        with open(f"jsons/{self.diagnosis_name}_drugs.json","w") as file:
            json.dump(file,total_overlap)

    def heuristic(self):
        model_weights=svc(model_preprocess()) # svc should be renamed to model_weights, allowing for different models.
                with open(f"jsons/{self.diagnosis_name}_drug_weight_end.json","w") as file:
            json.dump(file,drug_weight_end)

    def return_heuristic(node_i,node_j):
       start_to_drugs, between_drugs, drugs_to_end = self.load_files()
        # is in either dict, cannot be in all.
        if (node_i,node_j) or (node_j,node_i) in start_to_drugs.keys():
            return start_to_drugs.keys['(node_i,node_j)'] or start_to_drugs.keys['(node_i,node_j)']

        if (node_i,node_j) or (node_j,node_i) in between_drugs.keys():
            return between_drugs.keys['(node_i,node_j)'] or between_drugs.keys['(node_i,node_j)']

        if (node_i,node_j) or (node_j,node_i) in drugs_to_end.keys():
            return drugs_to_end.keys['(node_i,node_j)'] or drugs_to_end.keys['(node_i,node_j)']

    def load_files(self):

        with open(f"jsons/{self.diagnosis_name}_drug_weight_start.json","r") as file:
            start_to_drugs=json.load(file)

        with open(f"jsons/{self.diagnosis_name}_drugs.json","w") as file:
            between_drugs=json.dump(file)

        with open(f"jsons/{self.diagnosis_name}_drug_weight_end.json","w") as file:
            drugs_to_end=json.dump(file)

        return start_to_drugs, between_drugs, drugs_to_end

    def construct_graph(self):
        """
        Convert dicts of nodes and edges to nx.add_edges_from() format, then construct the graph.
        """
        start_to_drugs, between_drugs, drugs_to_end = self.load_files()

        start_to_drug_edges,between_drugs_edges,drugs_to_end_edges=[],[],[]
        for tuple_ in start_to_drugs:
            start_to_drug_edges.append((*tuple_, {'cost': start_to_drugs[tuple_]})
        for tuple_ in start_to_drugs:
            between_drugs_edges.append((*tuple_, {'cost': between_drugs[tuple_]})
        for tuple_ in start_to_drugs:
            drugs_to_end_edges.append((*tuple_, {'cost': drugs_to_end[tuple_]})

        # add the list elements together and construct the final graph.
        start_to_drug_edges.extend(between_drugs_edges)
        start_to_drug_edges.extend(drugs_to_end_edges)
        self.graph.add_edges_from(start_to_drug_edges)

    def nx_a_star(self):
        print(nx.astar_path(self.graph, 'start_node', 'end_node', heuristic=return_heuristic, weight='cost')


